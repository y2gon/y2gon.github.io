---
title: 컴퓨터가 수식과 구문구조를 이해하는 원리
subtitle : 프로그래밍 언어론 - 원리와 실제
date: 2022-02-02
category: General Knowledge for Programming
tags : [프로그래밍 언어, 구문법, syntax, 수식, expression, 구문구조, statement, 문맥-자유 문법, CFG, Context Free Grammar, BNF, Backus-Naur Form]
layout: post
---

해당 내용은 책 [<프로그래밍 언어론 - 원리와 실제 (저자: 창병모)>](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791185578729) 및 관련 검색으로 통해 학습한 내용임.

------------------------------------------------------------------------------

프로그래밍을 공부하기 시작하면서 신기한 것 중 하나는 code 작성 중 실시간으로 오타, 구문 에러, 타입 에러 등을 발견해서 작성자에게 알려준다는 것이였다. 실제로 해당 code 를 실행시키기 위해 인터프리터 언어든, 컴파일 언어든 내부적으로 복잡한 과정을 거쳐야 실행이 가능할텐데, 어떻게 이런 문제를 빠르게 확인해서 나에게 알려줄 수 있을까?


책에서 직접적으로 해답울 주지는 않았지만, 가장 가까운 결론을 얻을 수 있을 듯 하다.


### 1. 구문법 (Syntax)

길고 복잡한 프로그램을 컴퓨터가 읽고, 실행하기 위해 첫번째, code 를 읽는 규칙이 있을 것이다. 그 규칙대로 최소 단위부터 정해진 순서대로 적용하면서 읽고, 만약 이 과정에서 프로그래머가 작성한 내용이 규칙을 벗어날 경우, 작성자에게 오류를 알려줄 수 있을 것이다.

#### 1.1 수식 (expression)

  가장 작은 단위 숫자 및 사칙 연산을 기준으로 먼저 생각해보면,

  만약 어떤 프로그래밍 언어에 입력값 E 와 연산자(+, *, ()) 대해 다음의 규칙이 정의 되어 있다면 다음과 같은 계산이 가능하다.


                     구문법             의미                      
          E       -> E + E     V(E + E) = V(E) + V(E)  : 입력값(E)이 '+'로 연결되어 있는 경우 이를 분리하여 표기할 수 있음  
     (expression)  | E * E     V(E * E) = V(E) * V(E)  : 입력값(E)이 '*'로 연결되어 있는 경우 이를 분리하여 표기할 수 있음
                   | ( E )         V(( E )) = V(E)     : 입력값(E)이 '()'로 묶거나 해체하여도 동일한 값임이 정의되어 있음
                   |   N                V(N)           : 십진법 표기가 컴퓨터가 연산 가능한 이진법 N 으로 변환/인식이 가능함
                                                       : V(E) 는 어떤 입력값이 십진법으로 표시되어 있음을 의미
                                                       : N 은 실제 컴퓨터가 숫자로 인식 가능한 이진법 수를 의미

  위 구문법을 입력값 "3 * 5 + 12" 에 적용하면

        V((3 * 5) + 12)           (1) 적용                        
         =  V((3 * 5)) + V(12)    (3) 적용                       
         =  V(3 * 5) + V(12)      (2) 적용                       
         =  V(3) * V(5) + V(12)   (4) 적용                       
         =  3 * 5 +12             컴퓨터가 연산가능한 형태로 해석됨
         = 27                                                    

#### 1.2 구문구조 (statement)

그러나 프로그램이 수식으로만 이루어진 것은 아니다.
다양한 구문구조(statement) (ex. 대입문, 조건문, 반복문...) 는 어떻게 작동하는 것일까?
책에서는 추가 설명 없이, 구문구조도 입력값에 대해 정의하여 수식과 동일하게 사용할 수 있으며 이를 (문맥-자유 문법 (CFG: Context-Free Grammar))이라고 하며, 이에 대한 간단한 예시는 다음과 같다.

            S     ->    id = E               : 입력값 E 를 변수 id 에 대입    
       (statement) |  or if E then S else S  : 입력값 E 를 조건문에 적용     
                   | while(E) S              : 입력값 E 를 반복문에 적용      
                   | ...                                              

#### 1.3 결론

 * 프로그래밍 언어 구문법(Syntax) 가 입력되는 값의 최소단위(단어?) 기준으로 정의되어 있으며, 이를 기준으로 해석한다.

 * 만약 정의에 벗어나 표현을 입력했을 경우, Syntax error 를 작성자에게 알려 줄 수 있을 것이다.

 * Syntax 는 숫자만을 다루는 수식 (Expression) 과 CFG 에 근거하여 작성된 구문구조(statement) 가 있다.

------------------------------------------------------------------------------
### 2. 유도 (Derivation)

#### 2.1 구문법을 사용하여 다중 결합 수식 처리

앞에서 컴퓨터가 프로그램을 이해하는 최소 단위에 대해 알아보았다. 그렇다면 좀더 긴 수식은 어떻게 확인하고, 우리에게 오류를 알려 줄 수 있을까?

String E 가 "3 + 4 * 5" 일 때, syntax 가 다음과 같이 정의된 프로그램 언어 환경에 입력했을 경우,

  Defined Syntax

       E -> E + E | E * E | (E) | N                     : 입력값에 대해 +, *, () 연산 및 이진수로 해석 가능이 정의됨
       D -> 0  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0  : 0 ~ 9 컴퓨터가 인식 가능한 숫자 표기
       N -> D | ND                                      : 이진수는 그자체 또는 이진수와 숫자(0, 1) 의 연속 표기 형태

위 정의를 사용하여 다음의 유도(derivation) 과정을 통해 여려개의 연산자가 연결된 수식을 처리할 수 있다.

       E => E + E => N + E => D + E => 3 + E => 3 + E * E => 3 + N * E  
       => 3 + D * E => 3 + 4 * E => 3 + 4 * N => 3 + 4 * D => 3 + 4 * 5

하나의 입력된 덩어리 E에 대해, 정의된 syntax 내에서 참인 조건들로 위의 과정을 유도하면, 최종적으로 "3 + 4 * 5" 라는 String '참' 이 조건, 즉 컴퓨터가 계산 가능한 표현식(expression) 임이 증명되었다.

#### 2.2 유도 트리 (Derivation Tree)

이를 좀더 직관적으로 인식하기 위해 유도트리 (또는 파스 트리 (Parse Tree), 또는 구문 트리(Syntax Tree)) 로 표현하면 다음과 같다.

             E
           / | \   
          E  +  E
          |   / | \
          N   E * E
          |   |   |
         D(3) N   N
              |   |
             D(4) D(5)

이와 같이 분석이 완료 되었다면, 최하단 leaf node 부터 역으로 계산을 진행하면,

      (3) +  (4 * 5) = 3 + 20 = 23

의 정답을 얻을 수 있다.  

#### 2.3 모호성 문제
위 유도 및 파스트리를 이용한 방범은 사실 두가지로 해석 될수 있다. 만약 E 에 최초 Syntax 적용에서 + 가 아닌 * 부터 적용했다면 어떻까?

       E => E * E => E + E * E => N + E * E => 3 + E * E => 3 + N * E
      => 3 + 4 * E => 3 + 4 * N => 3 + 4 * 5

유도 과정은 기존과 큰 차이가 없어 보이지만, 해당 유도에 따라 parse tree 를 그리면 다음과 같다.

               E
             / | \   
            E  *  E
          / | \   |
         E  +  E  N
         |     |  |
         N     N  D(5)
         |     |
        D(3)  D(4)

그리고 계산을 진행하면,

       (3 + 4) * (5)  = 7 * 5 = 35

이렇게 어떤 스트링에 대해 두개 이상의 좌측 유도(해당 예제) 혹은 우측 유도를 갖는 문법을 모호한 문법 (ambiguous grammar) 라고 한다.

이런 모호성을 제거하기 위해 기존 수식(Expression) 에서 모든 연산을 동등하게 유도할 수 있게 or 관계로 묶여 있던 조건을 다음과 같이 T(term), F(factor) 규칙으로 나누어 세분화 해준다.


          E -> E + T | T      : 최초 입력문을 term 의 형태로 나눌 연산자 (+) 를 정의
          T -> T * F | F      : branch 진행 후, 2항 연산이 우선 적용될 연산자 (*) 를 정의
          F -> N | (E)        : 단항, 단일 표현식에 대해 적용될 연산자 binary 변환, () 을 정의

새로 정의된 syntax 에 따라 parse tree 를 생성하면, 최초 표현식에서 무조건 + 연산자에 대한 syntax 가 적용되어야 하므로 모호성 문제를 해결할 수 있다.

          E
        / | \   
       E  +  T
       |    /|\
       T   T * F
       |   |   |
       F   F   N
       |   |   |
       N   N   D(5)
       |   |   
      D(3) D(4)

--------------------------------------------------------------------------------------------------

### 3. BNF(Backus-Naur Form)

앞에서 작성한 syntax 를 BNF(Backus-Naur Form) 으로 작성하면 다음과 같다. (형식은 완전 동일)

       <expr> -> <expr> + <term> | <term>
       <term> -> <term> * <factor> | <factor>       
       <factor> -> number | ( <expr> ) v

#### 4. 결론

 * 위 조건 하나로 더 복잡하고 다양한 형태에 대한 모호성 문제를 해결했다고 볼 수 없으나, 기본 원리는 동일할 것을 예상할 수 있다.

 * Parse Tree 를 이용한 분석 방법은 직관적이며, 컴퓨터가 실제 계산을 진행하지 않고, 어떻게 code 의 적합성을 판단하는지 알 수 있다.   
